üõ†Ô∏è Ticket Title:

Add: Enum Validation for Create & Update ConfigurationProperty API

‚∏ª

üìù Description:

Introduce validation logic to ensure that enum fields (e.g., componentType, userType) in the ConfigurationProperty create and update APIs only accept valid enum values defined in the backend.

Invalid or unrecognized values should trigger a user-friendly error with proper HTTP 400 Bad Request response.

‚∏ª

‚úÖ Acceptance Criteria:
	‚Ä¢	Validate enum fields using Enum::name() mapping or a dedicated utility.
	‚Ä¢	Return clear error message listing allowed values if an invalid value is provided.
	‚Ä¢	Apply this check for both create and update flows.
	‚Ä¢	Add test cases to validate correct behavior for valid and invalid enums.

‚∏ª

üîç Impact:

Prevents invalid or unexpected enum values from being stored, improving data integrity and reducing downstream errors.

üîç Validation Details Implemented:
	‚Ä¢	Introduced validation for enum fields such as componentType and userType during both create and update operations of ConfigurationProperty.
	‚Ä¢	Validation logic compares incoming values against the full list of supported enum constants using Enum::name().toUpperCase() for case-insensitive matching.
	‚Ä¢	If the value is null or does not match any of the allowed enums:
	‚Ä¢	A ConfigurationPropertyServiceException is thrown.
	‚Ä¢	The exception message clearly lists the accepted values, improving debuggability and user feedback.
	‚Ä¢	Example message returned on invalid input:

Kindly provide the correct componentType. Allowed values: [TYPE_A, TYPE_B, TYPE_C]

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 
Ticket Title:

Fix: Property Configuration Update API ‚Äì Certain fields not updating

‚∏ª

Description:

The Property Configuration Update API is not correctly updating all expected fields. Specifically, fields like name, component, or others provided in the request body are not being persisted when modified.

‚∏ª

Acceptance Criteria:
	‚Ä¢	Ensure all updatable fields from the incoming payload are correctly mapped and saved.
--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 

Jira Ticket

Title:
Implement Account Lockout Mechanism with Manual Unlock API

Type:
Feature

Priority:
High

Assignee:
(Your name or backend team member)

Labels:
spring-boot, mongodb, security, authentication, admin-api

‚∏ª

‚úÖ Description

Objective:
Implement a secure account lockout mechanism in the authentication system of our Spring Boot + MongoDB application. Lock the user account after 5 failed login attempts and provide an admin-only endpoint to unlock the account.

‚∏ª

‚úÖ Acceptance Criteria
	1.	After 5 consecutive failed password attempts:
	‚Ä¢	The user‚Äôs accountLocked flag is set to true.
	‚Ä¢	The failedLoginAttempts and lockTime are stored in the database.
	2.	During login:
	‚Ä¢	If a locked account is detected, an appropriate error message is returned:
‚ÄúYour account is locked. Please contact admin to unlock.‚Äù
	3.	Admins can unlock users via the new API:

PUT /api/admin/unlock/{username}

	4.	On unlock:
	‚Ä¢	accountLocked is reset to false
	‚Ä¢	failedLoginAttempts is reset to 0
	‚Ä¢	lockTime is cleared
	5.	Converters and encryption:
	‚Ä¢	The accountLocked field is encrypted using Spring Data MongoDB‚Äôs @ValueConverter with a custom AES-based encryption logic via EncryptedBooleanConverter.
	6.	Security:
	‚Ä¢	Unlock API is protected with ROLE_ADMIN access.
	‚Ä¢	Unlock actions are logged for audit purposes.

‚∏ª

‚úÖ Technical Implementation Summary
	‚Ä¢	Updated User entity to include:
	‚Ä¢	failedLoginAttempts, accountLocked, lockTime
	‚Ä¢	Used @ValueConverter(EncryptedBooleanConverter.class) to store encrypted account lock status.
	‚Ä¢	Added custom converters via PropertyValueConverter<Boolean, String, ValueConversionContext>.
	‚Ä¢	Added lockout logic inside AuthenticationService.authenticate().
	‚Ä¢	Added admin controller with:
	‚Ä¢	PUT /api/admin/unlock/{username}
	‚Ä¢	Optional: Enabled Spring Security role-based access on unlock endpoint.
	‚Ä¢	Optional: Logging unlock actions via SLF4J or to an AuditLog collection.

‚úÖ Feature implemented and verified:
	1.	Account is now locked after 5 consecutive failed login attempts.
	2.	Lockout status (accountLocked) is stored in encrypted format using @ValueConverter and a custom EncryptedBooleanConverter.
	3.	User receives proper error message when account is locked: ‚ÄúYour account is locked. Please contact admin to unlock.‚Äù
	4.	Admin unlock API added at PUT /api/admin/unlock/{username} ‚Äî resets lock status, attempts, and timestamp.
	5.	Spring Security role-based protection (ROLE_ADMIN) applied to the unlock endpoint.
	6.	Manual unlock actions are logged for traceability.
	7.	Code reviewed and tested locally and on dev environment.

‚úÖ Ready for QA validation.
--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 
Here is the updated Jira ticket including the additional behavior for local and SSO user types:


---

Title:
Backend - Add User Type to Distinguish Between Local and SSO Users During User Creation

Type:
Feature / Backend Enhancement

Description:
Enhance the backend user creation logic to introduce a userType field that distinguishes between Local and SSO users. Based on this type, apply conditional handling for password generation and sharing.

Objective:

Introduce user type-based behavior during user creation.

Improve handling of password creation and sharing based on user type.


Scope of Work:

Add a userType field (LOCAL or SSO) to the user entity and database schema.

Update user creation logic:

For LOCAL users: Generate a password and return/show it to the user upon successful creation.

For SSO users: Generate and save a password internally, but do not return/share it with the user.


Apply default behavior if userType is not provided (e.g., default to LOCAL).

Ensure sensitive data like passwords are stored securely (hashed).

Update unit and integration tests.

Modify API documentation accordingly.


Acceptance Criteria:

[ ] userType is saved correctly in the DB as LOCAL or SSO.

[ ] For LOCAL users, password is returned in the API response.

[ ] For SSO users, password is generated and stored, but not shown to the user.

[ ] System behavior is validated with test coverage.

[ ] No breaking changes in existing user management flows.


Impact Area:

User Creation API

User Entity & Repository

Password Generation Utility

DB Schema (if needed)


Assignee:
[Assign as needed]

Priority:
[Medium / High]


---

Would you like me to provide a sample API request/response for clarity as part of this ticket?



Here‚Äôs a professional Jira ticket description for your requirement:


---

Title:
Backend - Add User Type to Distinguish Between Local and SSO Users During User Creation

Type:
Feature / Backend Enhancement

Description:
Enhance the user creation process in the backend to include a userType field that clearly distinguishes between Local and SSO users. This distinction will support better access control, auditing, and user management across the system.

Objective:

Introduce a userType attribute (e.g., LOCAL, SSO) during user creation.

Ensure all user records reflect the correct type at the time of onboarding.


Scope of Work:

Update user entity/model to include a new userType field.

Modify user creation logic to accept and set this value appropriately.

Update DB schema/migration script if needed.

Apply validation and defaulting logic (e.g., default to LOCAL if not provided).

Update any related user fetch APIs to include the new field.

Reflect changes in API documentation.


Acceptance Criteria:

[ ] userType field is added to the user model and database.

[ ] User creation endpoint accepts userType and persists it correctly.

[ ] The field accepts only valid enum values (e.g., LOCAL, SSO).

[ ] All new users are saved with the correct type.

[ ] Unit and integration tests cover the new logic.

[ ] No impact on existing user functionality.


Impact Area:

User Entity and Service

User Creation API

Database Schema

Audit/Access Logs (if applicable)


Assignee:
[Assign as needed]

Priority:
[Medium / High, based on business need]


---

Would you like to enforce different validations or behavior based on user type as well?



@Component
public class ValidationUtils {

    @Autowired
    private Validator validator;

    public <T> void validate(T object) {
        Set<ConstraintViolation<T>> violations = validator.validate(object);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
}

public class RoleNameValidator implements ConstraintValidator<ValidRoleName, String> {

    private static final Pattern ROLE_PATTERN = Pattern.compile("^[A-Z]+(?:_[A-Z]+)*$");

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.isBlank()) return false;
        if (value.startsWith("_") || value.endsWith("_")) return false;
        if (value.contains("__")) return false;
        return ROLE_PATTERN.matcher(value).matches();
    }
}

Here‚Äôs a professional Jira ticket description for your request:


---

Title:
Backend Endpoint to Retrieve Engine Configuration in JSON Format

Type:
Feature / Backend API

Description:
Develop a backend API endpoint to retrieve engine configuration details in a specific JSON format. The response should include key-value pairs, where the key name (e.g., apix_key) is dynamically derived from the configuration properties stored in the engine configuration database.

Objective:

Expose a clean, structured JSON API for engine configuration retrieval.

Dynamically fetch key names from configuration properties stored in the DB.


Expected Response Format:

{
  "apix_key": "some value"
}

Scope of Work:

Create a GET endpoint (e.g., /api/engine/config).

Fetch the required property key name and its corresponding value from the engine configuration table.

Build and return the JSON response using the key name from the DB.

Ensure proper error handling if the key or value is not present.

Secure the endpoint if necessary.


Acceptance Criteria:

[ ] Endpoint is accessible and returns configuration in the specified JSON format.

[ ] Key name is fetched dynamically from the DB.

[ ] Proper logging and exception handling are in place.

[ ] Unit and integration tests are added.

[ ] API documentation is updated if required.


Impact Area:

Engine Configuration Service

API Controller Layer

Configuration DB Access


Assignee:
[Assign as needed]

Priority:
[Set as appropriate ‚Äì e.g., High/Medium]


---

Would you like to include authentication or role-based access control for this endpoint?



Here‚Äôs a professional Jira ticket description for your request:


---

Title:
Refactoring - Create Role Using Naming Convention ENGINE_VIEW_ROLE

Type:
Refactor / Backend Enhancement

Description:
Refactor the role creation logic to introduce a new role named ENGINE_VIEW_ROLE, adhering to the standard naming conventions for role identifiers.

Objective:

Maintain consistent naming conventions for system roles.

Ensure the new role is properly registered, persisted, and available for assignment within the system.


Scope of Work:

Create a new role with the name ENGINE_VIEW_ROLE.

Follow the existing role creation pattern and align with naming standards (uppercase with underscores).

Add the role to default role enumeration/configuration if applicable.

Ensure the role is available in any role management UI or API.

Add test cases to verify role creation and retrieval.


Acceptance Criteria:

[ ] Role ENGINE_VIEW_ROLE is created and saved in the system.

[ ] Naming conventions are strictly followed.

[ ] The role is visible and assignable in the system.

[ ] All relevant tests are updated or added.

[ ] No regression issues in role management modules.


Impact Area:

Role Service / Role Entity

Role initialization scripts or configurations

Related role management UI or APIs


Assignee:
[Assign as needed]

Priority:
[Set as appropriate ‚Äì e.g., Medium]


---

Would you like this in Jira Markdown format or include it in a user story format?



Here‚Äôs a detailed and professional Jira ticket description for your requirement:


---

Title:
Modify TCT Backend to Use Single DB (Disable Multitenancy via Config)

Type:
Refactor / Configuration Update

Description:
Refactor the TCT backend to use a single database instead of the current multi-tenant setup. If feasible, disable multitenancy through a configuration switch. Retain and comment out the existing multitenancy code for potential future use, as discussed with Shyam.

Objective:

Simplify the backend setup by switching to a single DB mode.

Ensure flexibility to re-enable multitenancy in the future if required.


Scope of Work:

Introduce a configuration flag to control multitenancy enablement.

When multitenancy is disabled, route all operations to the default single database instance.

Comment out multitenancy-related code blocks without deletion for future reference.

Ensure no impact on existing functionality.

Test application behavior with both single DB and multitenancy modes.


Acceptance Criteria:

[ ] A config property is introduced to enable/disable multitenancy.

[ ] When disabled, the system operates with a single database instance.

[ ] All multitenancy logic is safely commented with clear annotations.

[ ] Application runs without errors in single DB mode.

[ ] Changes verified and confirmed with Shyam.

[ ] All related test cases are updated accordingly.


Impact Area:

Configuration files

Tenant resolution/interceptor logic

Repository/data access layer


Assignee:
[Assign as needed]

Priority:
[Set based on sprint planning ‚Äì e.g., Medium/High]


---

Would you like this converted into Jira Markdown format as well?



Here‚Äôs a professional and complete Jira ticket description based on your input:


---

Title:
Refactoring - Create Organization with Default Team

Type:
Refactor / Enhancement

Description:
This task involves refactoring the existing Create Organization functionality to ensure that a default team is automatically created whenever a new organization is added to the system.

Objective:

Simplify onboarding by ensuring every organization has at least one team by default.

Improve data consistency and avoid edge cases where an organization exists without a team.


Scope of Work:

Modify the organization creation flow to include the creation of a default team (e.g., ‚ÄúDefault Team‚Äù or configurable name).

Ensure transactional consistency: if default team creation fails, the organization creation should be rolled back.

Add appropriate unit and integration tests.

Update API documentation if applicable.


Acceptance Criteria:

[ ] Organization creation API returns success only if default team is also created.

[ ] Default team appears under the newly created organization in the system.

[ ] Unit tests for successful and failed team creation scenarios are added.

[ ] Code follows project-level coding standards and passes code review.


Impact Area:

Organization Service / Team Service

Database schema (if any changes are required)


Assignee:
[Assign as needed]

Priority:
[Set as per team standards ‚Äì e.g., Medium/High]


---

Would you like this in Jira Markdown format too?



Before starting development on this ticket, the following details are required:

API endpoint and request payload details for invoking the push notification service.


Additionally, the following prerequisite tickets need to be completed before proceeding with this work:

Ticket No. 1

Ticket No. 2


Kindly provide the necessary information and complete the dependencies to unblock this ticket.


Here‚Äôs your corrected and professional version of the paragraph:


---

This update is related to creating secrets using our TCT tool.
Currently, we have the flexibility to update the region configuration, and based on the selected region, the tool will create the secret in that region.

This change will not impact the existing secrets unless a new region is explicitly provided.
For local development, the application can use this variable to run properly.

In the existing ECS service, the DevOps team can configure and update this variable value as needed for the application.


---

Would you also like a slightly more concise version depending on where you're planning to use it (e.g., Jira ticket, email, Confluence)?





